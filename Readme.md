# Java Web Application Deployment on AWS EKS with Jenkins


Build Restful CRUD API for a simple Note-Taking application using Spring Boot, Mysql.
i am using this as a sample java application for demo purpose

## Please find Requirements

1. Java - 1.8.x

2. Maven - 3.x.x

3. Mysql - 5.x.x

## Steps to Setup

**1. Clone the application**

```bash
git clone https://github.com/callicoder/spring-boot-mysql-rest-api-tutorial.git
```

**2. Create Mysql database**
```bash
Created A stateful set for mysql and expose as headless service
```

**3.  for connection mysql username and password as per our installation**

+ open `we have created notes.yaml deployment open the notes.yaml`

+ change `username` and `password` and `db_ip` as per your mysql installation

**4. Build and run the app using maven and then dockerize**

```bash
mvn package
docker build -t your-image-name:your-image-tag .
```

**5.  Push the Docker image to ECR**

```bash
aws ecr get-login-password --region your-aws-region | docker login --username AWS --password-stdin your-aws-account-id.dkr.ecr.your-aws-region.amazonaws.com
docker tag your-image-name:your-image-tag your-aws-account-id.dkr.ecr.your-aws-region.amazonaws.com/your-repository-name:your-image-tag
docker push your-aws-account-id.dkr.ecr.your-aws-region.amazonaws.com/your-repository-name:your-image-tag
```
**6. Configure the Jenkins pipeline**
Create a new Jenkins pipeline and configure it to use the following stages:

+ open `Checkout code from GitHub`
+ open `Build the application using Maven`
+ open `Dockerize the application`
+ open `Push the Docker image to ECR`
+ open `Deploy the application to EKS`

## Integration with AWS CodeCommit and Lambda Function
To automate the pipeline, I have integrated AWS CodeCommit with Jenkins using a Lambda function. Whenever a code change is made to the repository, the Lambda function triggers the Jenkins pipeline to build and deploy the new code changes.

This integration enables automatic build and deployment of new code changes, reducing the need for manual intervention, and increasing the efficiency of the development process.
The app will start running at <http://localhost:80>.

## Zero Downtime Deployment
To achieve zero downtime deployment, I use the latest build number generated by Jenkins as the image tag when pushing the Docker image to AWS ECR. Then, I update the deployment file with the new image tag and apply the changes to the Kubernetes cluster using kubectl apply.

By using this approach, we can ensure that the new version of the application is rolled out gradually, without any disruption to the users of the application.

## Jenkins Pipeline
The Jenkins pipeline for this project consists of the following stages:

1. Build: This stage clones the Git repository and builds the Java web application using Maven.

2. Docker Build: This stage builds a Docker image of the application and tags it with the latest version.

3. Logging into AWS ECR: This stage logs into the AWS ECR (Elastic Container Registry) using AWS CLI.

4. Push to ECR: This stage pushes the Docker image to the AWS ECR.

5. Deploy to EKS: This stage updates the deployment file with the new Docker image tag and deploys it to the AWS EKS cluster.
## Explore Rest APIs

The app defines following CRUD APIs.

    GET /api/notes
    
    POST /api/notes
    
    GET /api/notes/{noteId}
    
    PUT /api/notes/{noteId}
    
    DELETE /api/notes/{noteId}
